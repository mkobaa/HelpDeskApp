{"file":"useToast-CPJFKRUV.js","mappings":";;AAEO,MAAM,uBAAuB,uBAAO,mBAAmB;AACvD,SAAS,WAAW;AACzB,QAAM,SAAS,SAAS,UAAU,MAAM,CAAA,CAAE;AAC1C,QAAM,MAAM,OAAO,sBAAsB,MAAM;AAC/C,QAAM,UAAU,IAAI,KAAK;AACzB,QAAM,QAAQ,CAAA;AACd,QAAM,aAAa,MAAM,GAAG,KAAK,IAAG,CAAE,IAAI,KAAK,OAAM,EAAG,SAAS,EAAE,EAAE,MAAM,GAAG,CAAC,CAAC;AAChF,iBAAe,eAAe;AAC5B,QAAI,QAAQ,SAAS,MAAM,WAAW,GAAG;AACvC;AAAA,IACF;AACA,YAAQ,QAAQ;AAChB,WAAO,MAAM,SAAS,GAAG;AACvB,YAAM,QAAQ,MAAM,MAAK;AACzB,YAAM,SAAQ;AACd,aAAO,QAAQ,CAAC,GAAG,OAAO,OAAO,KAAK,EAAE,MAAM,EAAE,KAAK,SAAS,EAAE;AAAA,IAClE;AACA,YAAQ,QAAQ;AAAA,EAClB;AACA,WAAS,IAAI,OAAO;AAClB,UAAM,OAAO;AAAA,MACX,IAAI,WAAU;AAAA,MACd,MAAM;AAAA,MACN,GAAG;AAAA,IACT;AACI,UAAM,KAAK,IAAI;AACf,iBAAY;AACZ,WAAO;AAAA,EACT;AACA,WAAS,OAAO,IAAI,OAAO;AACzB,UAAM,QAAQ,OAAO,MAAM,UAAU,CAAC,MAAM,EAAE,OAAO,EAAE;AACvD,QAAI,UAAU,IAAI;AAChB,aAAO,MAAM,KAAK,IAAI;AAAA,QACpB,GAAG,OAAO,MAAM,KAAK;AAAA,QACrB,GAAG;AAAA,MACX;AAAA,IACI;AAAA,EACF;AACA,WAAS,OAAO,IAAI;AAClB,UAAM,QAAQ,OAAO,MAAM,UAAU,CAAC,MAAM,EAAE,OAAO,EAAE;AACvD,QAAI,UAAU,IAAI;AAChB,aAAO,MAAM,KAAK,IAAI;AAAA,QACpB,GAAG,OAAO,MAAM,KAAK;AAAA,QACrB,MAAM;AAAA,MACd;AAAA,IACI;AACA,eAAW,MAAM;AACf,aAAO,QAAQ,OAAO,MAAM,OAAO,CAAC,MAAM,EAAE,OAAO,EAAE;AAAA,IACvD,GAAG,GAAG;AAAA,EACR;AACA,WAAS,QAAQ;AACf,WAAO,QAAQ,CAAA;AAAA,EACjB;AACA,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACJ;AACA;","names":[],"sources":["../../../../../../@nuxt/ui/dist/runtime/composables/useToast.js"],"sourcesContent":["import { ref, nextTick, inject } from \"vue\";\nimport { useState } from \"#imports\";\nexport const toastMaxInjectionKey = Symbol(\"nuxt-ui.toast-max\");\nexport function useToast() {\n  const toasts = useState(\"toasts\", () => []);\n  const max = inject(toastMaxInjectionKey, void 0);\n  const running = ref(false);\n  const queue = [];\n  const generateId = () => `${Date.now()}-${Math.random().toString(36).slice(2, 9)}`;\n  async function processQueue() {\n    if (running.value || queue.length === 0) {\n      return;\n    }\n    running.value = true;\n    while (queue.length > 0) {\n      const toast = queue.shift();\n      await nextTick();\n      toasts.value = [...toasts.value, toast].slice(-(max?.value ?? 5));\n    }\n    running.value = false;\n  }\n  function add(toast) {\n    const body = {\n      id: generateId(),\n      open: true,\n      ...toast\n    };\n    queue.push(body);\n    processQueue();\n    return body;\n  }\n  function update(id, toast) {\n    const index = toasts.value.findIndex((t) => t.id === id);\n    if (index !== -1) {\n      toasts.value[index] = {\n        ...toasts.value[index],\n        ...toast\n      };\n    }\n  }\n  function remove(id) {\n    const index = toasts.value.findIndex((t) => t.id === id);\n    if (index !== -1) {\n      toasts.value[index] = {\n        ...toasts.value[index],\n        open: false\n      };\n    }\n    setTimeout(() => {\n      toasts.value = toasts.value.filter((t) => t.id !== id);\n    }, 200);\n  }\n  function clear() {\n    toasts.value = [];\n  }\n  return {\n    toasts,\n    add,\n    update,\n    remove,\n    clear\n  };\n}\n"],"version":3}